<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Flappy Bird - Cross-Device with Game Over</title>
<style>
  body { margin:0; overflow:hidden; background:#000; }
  canvas { display:block; background:url('assets/background.png') no-repeat center/cover; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const BASE_WIDTH = 500;
const BASE_HEIGHT = 700;

let SCREEN_WIDTH = window.innerWidth;
let SCREEN_HEIGHT = window.innerHeight;
canvas.width = SCREEN_WIDTH;
canvas.height = SCREEN_HEIGHT;

// Assets
let birdImg = new Image(); birdImg.src='assets/bird.png';
let pipeImg = new Image(); pipeImg.src='assets/pipe.png';
let wingSound = new Audio('assets/sounds/wing.wav');
let hitSound = new Audio('assets/sounds/hit.wav');
let pointSound = new Audio('assets/sounds/point.wav');

// Game state
let bird, pipes, spawnTimer, score;
let gameState = "menu";

// Physics (fixed values)
const GRAVITY = 0.35;
const FLAP_STRENGTH = -8;
const PIPE_SPEED = 3;
let COLLISION_PADDING = 5;

// Pipes
let PIPE_WIDTH, PIPE_GAP, spawnInterval;

// Scaling
function updateProportions() {
    SCREEN_WIDTH = window.innerWidth;
    SCREEN_HEIGHT = window.innerHeight;
    canvas.width = SCREEN_WIDTH;
    canvas.height = SCREEN_HEIGHT;

    let scale = Math.min(SCREEN_WIDTH/BASE_WIDTH, SCREEN_HEIGHT/BASE_HEIGHT);

    bird.width = Math.max(40*scale, 30);
    bird.height = Math.max(40*scale, 30);

    if(SCREEN_WIDTH <= 768){
        PIPE_WIDTH = Math.max(60*scale, 50);
        PIPE_GAP = Math.max(220*scale, 150);
        spawnInterval = Math.max(250*scale, 150);
    } else {
        PIPE_WIDTH = Math.max(80*scale, 50);
        PIPE_GAP = Math.max(200*scale, 150);
        spawnInterval = Math.max(300*scale, 150);
    }

    pipes.forEach(pipe => pipe.width = PIPE_WIDTH);
}

// Bird class
class Bird {
    constructor(){
        this.x = SCREEN_WIDTH/5;
        this.y = SCREEN_HEIGHT/2;
        this.width = 40;
        this.height = 40;
        this.velocity = 0;
    }
    flap(){ this.velocity = FLAP_STRENGTH; wingSound.play(); }
    update(deltaTime){
        this.velocity += GRAVITY * deltaTime * 60;
        this.y += this.velocity * deltaTime * 60;
    }
    draw(){ ctx.drawImage(birdImg, this.x, this.y, this.width, this.height); }
    hitbox(){ return {x:this.x+COLLISION_PADDING, y:this.y+COLLISION_PADDING, width:this.width-2*COLLISION_PADDING, height:this.height-2*COLLISION_PADDING}; }
}

// Pipe class
class Pipe {
    constructor(x){
        this.x = x;
        this.width = PIPE_WIDTH;
        const minTop = 50;
        const maxTop = SCREEN_HEIGHT - PIPE_GAP - 50;
        this.topHeight = Math.floor(Math.random()*(maxTop - minTop + 1)) + minTop;
        this.bottomY = this.topHeight + PIPE_GAP;
        this.passed = false;
    }
    update(deltaTime){ this.x -= PIPE_SPEED * deltaTime * 60; }
    draw(){
        // Top pipe
        ctx.save();
        ctx.translate(this.x+this.width/2, this.topHeight/2);
        ctx.scale(1,-1);
        ctx.drawImage(pipeImg,-this.width/2,-this.topHeight/2,this.width,this.topHeight);
        ctx.restore();
        // Bottom pipe
        ctx.drawImage(pipeImg,this.x,this.bottomY,this.width,SCREEN_HEIGHT-this.bottomY);
    }
    topRect(){ return {x:this.x, y:0, width:this.width, height:this.topHeight}; }
    bottomRect(){ return {x:this.x, y:this.bottomY, width:this.width, height:SCREEN_HEIGHT-this.bottomY}; }
}

// Reset game
function resetGame(){ bird=new Bird(); pipes=[]; spawnTimer=0; score=0; }

// Draw text
function drawText(text,x,y,size){ ctx.fillStyle="white"; ctx.font=`${size}px Comic Sans MS`; ctx.textAlign="center"; ctx.fillText(text,x,y); }
function rectsCollide(r1,r2){ return r1.x<r2.x+r2.width && r1.x+r1.width>r2.x && r1.y<r2.y+r2.height && r1.y+r1.height>r2.y; }

// Draw Game Over screen
function drawGameOver(){
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.fillRect(0,0,SCREEN_WIDTH,SCREEN_HEIGHT);
    drawText("GAME OVER", SCREEN_WIDTH/2, SCREEN_HEIGHT/3, 60);
    drawText(`Final Score: ${score}`, SCREEN_WIDTH/2, SCREEN_HEIGHT/2, 40);
    drawText("Tap/Click or SPACE to Restart", SCREEN_WIDTH/2, SCREEN_HEIGHT*2/3, 30);
}

let lastTime = performance.now();

// Game loop using deltaTime
function gameLoop(currentTime){
    const deltaTime = (currentTime - lastTime)/1000;
    lastTime = currentTime;

    updateProportions();
    ctx.clearRect(0,0,SCREEN_WIDTH,SCREEN_HEIGHT);

    if(gameState==="menu"){
        drawText("Flappy Bird", SCREEN_WIDTH/2, SCREEN_HEIGHT/4, 60);
        drawText("Tap/Click or SPACE to play", SCREEN_WIDTH/2, SCREEN_HEIGHT/2, 30);
    } else if(gameState==="playing"){
        bird.update(deltaTime);
        bird.draw();

        spawnTimer += PIPE_SPEED * deltaTime * 60;
        if(spawnTimer >= spawnInterval){ pipes.push(new Pipe(SCREEN_WIDTH)); spawnTimer=0; }

        pipes.forEach(pipe=>{
            pipe.update(deltaTime);
            pipe.draw();

            if(rectsCollide(bird.hitbox(),pipe.topRect()) || rectsCollide(bird.hitbox(),pipe.bottomRect())){
                hitSound.play(); gameState="gameover";
            }
            if(!pipe.passed && pipe.x + pipe.width < bird.x){ pipe.passed=true; score++; pointSound.play(); }
        });

        pipes = pipes.filter(pipe=>pipe.x + pipe.width > 0);

        if(bird.y + bird.height >= SCREEN_HEIGHT || bird.y <= 0){ hitSound.play(); gameState="gameover"; }

        drawText(score, 50, 50, 40);

    } else if(gameState==="gameover"){
        drawGameOver();
    }

    requestAnimationFrame(gameLoop);
}

// Input
document.addEventListener('keydown', e=>{
    if(e.code==="Space"){
        if(gameState==="menu" || gameState==="gameover") resetGame(), gameState="playing";
        else if(gameState==="playing") bird.flap();
    }
});
canvas.addEventListener('mousedown', ()=>{
    if(gameState==="menu" || gameState==="gameover") resetGame(), gameState="playing";
    else if(gameState==="playing") bird.flap();
});
canvas.addEventListener('touchstart', e=>{
    e.preventDefault();
    if(gameState==="menu" || gameState==="gameover") resetGame(), gameState="playing";
    else if(gameState==="playing") bird.flap();
},{passive:false});

// Resize
window.addEventListener('resize', ()=>updateProportions());

// Start
resetGame();
requestAnimationFrame(gameLoop);
</script>
</body>
</html>
