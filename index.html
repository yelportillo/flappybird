<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flappy Bird</title>
<style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; background: url('assets/background.png') no-repeat center/cover; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let SCREEN_WIDTH = window.innerWidth;
let SCREEN_HEIGHT = window.innerHeight;
canvas.width = SCREEN_WIDTH;
canvas.height = SCREEN_HEIGHT;

let birdImg = new Image();
birdImg.src = 'assets/bird.png';

let pipeImg = new Image();
pipeImg.src = 'assets/pipe.png';

let wingSound = new Audio('assets/sounds/wing.wav');
let hitSound = new Audio('assets/sounds/hit.wav');
let pointSound = new Audio('assets/sounds/point.wav');

const GRAVITY = 0.5;
const FLAP_STRENGTH = -10;
const PIPE_SPEED = 3;
let COLLISION_PADDING = 5;

let bird, pipes, spawnTimer, score;
let gameState = "menu";

// Scaling based on screen
function updateProportions() {
    SCREEN_WIDTH = window.innerWidth;
    SCREEN_HEIGHT = window.innerHeight;
    canvas.width = SCREEN_WIDTH;
    canvas.height = SCREEN_HEIGHT;

    // Bird
    bird.width = 40;
    bird.height = 40;

    // Pipes
    PIPE_WIDTH = Math.floor(SCREEN_HEIGHT * 0.08); // 8% of screen height
    PIPE_GAP = Math.floor(SCREEN_HEIGHT * 0.25);   // vertical gap proportional
    spawnInterval = Math.floor(SCREEN_WIDTH * 0.4); // horizontal spacing proportional

    // Reset pipe widths for existing pipes
    pipes.forEach(pipe => pipe.width = PIPE_WIDTH);
}

// Bird class
class Bird {
    constructor() {
        this.x = SCREEN_WIDTH / 5;
        this.y = SCREEN_HEIGHT / 2;
        this.width = 40;
        this.height = 40;
        this.velocity = 0;
    }
    flap() {
        this.velocity = FLAP_STRENGTH;
        wingSound.play();
    }
    update() {
        this.velocity += GRAVITY;
        this.y += this.velocity;
    }
    draw() {
        ctx.drawImage(birdImg, this.x, this.y, this.width, this.height);
    }
    hitbox() {
        return {x: this.x+COLLISION_PADDING, y: this.y+COLLISION_PADDING, width:this.width-2*COLLISION_PADDING, height:this.height-2*COLLISION_PADDING};
    }
}

// Pipe class
class Pipe {
    constructor(x) {
        this.x = x;
        this.width = PIPE_WIDTH;
        const minTop = 50;
        const maxTop = SCREEN_HEIGHT - PIPE_GAP - 50;
        this.topHeight = Math.floor(Math.random() * (maxTop - minTop + 1)) + minTop;
        this.bottomY = this.topHeight + PIPE_GAP;
        this.passed = false;
    }
    update() { this.x -= PIPE_SPEED; }
    draw() {
        // Top pipe
        ctx.save();
        ctx.translate(this.x + this.width/2, this.topHeight/2);
        ctx.scale(1,-1);
        ctx.drawImage(pipeImg, -this.width/2, -this.topHeight/2, this.width, this.topHeight);
        ctx.restore();
        // Bottom pipe
        ctx.drawImage(pipeImg, this.x, this.bottomY, this.width, SCREEN_HEIGHT - this.bottomY);
    }
    topRect() { return {x:this.x, y:0, width:this.width, height:this.topHeight}; }
    bottomRect() { return {x:this.x, y:this.bottomY, width:this.width, height:SCREEN_HEIGHT - this.bottomY}; }
}

// Initialize game state
function resetGame() {
    bird = new Bird();
    pipes = [];
    spawnTimer = 0;
    score = 0;
}

// Utility functions
function drawText(text, x, y, size) {
    ctx.fillStyle = "white";
    ctx.font = `${size}px Comic Sans MS`;
    ctx.textAlign = "center";
    ctx.fillText(text, x, y);
}
function rectsCollide(r1,r2) {
    return r1.x < r2.x + r2.width && r1.x + r1.width > r2.x &&
           r1.y < r2.y + r2.height && r1.y + r1.height > r2.y;
}

// Game loop
function gameLoop() {
    updateProportions();
    ctx.clearRect(0,0,SCREEN_WIDTH,SCREEN_HEIGHT);

    if(gameState==="menu"){
        drawText("Flappy Bird", SCREEN_WIDTH/2, SCREEN_HEIGHT/4, 60);
        drawText("Press SPACE or CLICK to play", SCREEN_WIDTH/2, SCREEN_HEIGHT/2, 30);
    } else if(gameState==="playing"){
        bird.update();
        bird.draw();

        spawnTimer += PIPE_SPEED;
        if(spawnTimer >= spawnInterval){
            pipes.push(new Pipe(SCREEN_WIDTH));
            spawnTimer = 0;
        }

        pipes.forEach(pipe=>{
            pipe.update();
            pipe.draw();

            if(rectsCollide(bird.hitbox(), pipe.topRect()) || rectsCollide(bird.hitbox(), pipe.bottomRect())){
                hitSound.play();
                gameState = "gameover";
            }
            if(!pipe.passed && pipe.x+pipe.width<bird.x){
                pipe.passed = true;
                score++;
                pointSound.play();
            }
        });

        pipes = pipes.filter(pipe=>pipe.x+pipe.width>0);

        if(bird.y+bird.height>=SCREEN_HEIGHT || bird.y<=0){
            hitSound.play();
            gameState="gameover";
        }

        drawText(score, 50, 50, 40);

    } else if(gameState==="gameover"){
        drawText("GAME OVER", SCREEN_WIDTH/2, SCREEN_HEIGHT/4, 60);
        drawText(`Score: ${score}`, SCREEN_WIDTH/2, SCREEN_HEIGHT/2, 40);
        resetGame();
        gameState="menu";
    }

    requestAnimationFrame(gameLoop);
}

// Input
document.addEventListener('keydown', e=>{
    if(e.code==="Space"){
        if(gameState==="menu") gameState="playing";
        else if(gameState==="playing") bird.flap();
    }
});
canvas.addEventListener('mousedown', ()=>{
    if(gameState==="menu") gameState="playing";
    else if(gameState==="playing") bird.flap();
});

// Window resize
window.addEventListener('resize', ()=>updateProportions());

// Start game
resetGame();
gameLoop();
</script>
</body>
</html>
