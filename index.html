<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flappy Bird</title>
<style>
    body { margin: 0; overflow: hidden; background: #000; }
    canvas { display: block; margin: 0 auto; background: url('assets/background.png') no-repeat center/cover; }
    #leaderboard {
        position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
        color: white; font-family: 'Comic Sans MS'; font-size: 20px;
    }
</style>
</head>
<body>
<canvas id="gameCanvas" width="500" height="700"></canvas>
<div id="leaderboard"></div>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const SCREEN_WIDTH = canvas.width;
const SCREEN_HEIGHT = canvas.height;

const GRAVITY = 0.5;
const FLAP_STRENGTH = -10;
const PIPE_SPEED = 3;
const PIPE_WIDTH = 120;
const PIPE_GAP = 200;
const COLLISION_PADDING = 5;

let birdImg = new Image();
birdImg.src = 'assets/bird.png';

let pipeImg = new Image();
pipeImg.src = 'assets/pipe.png';

let wingSound = new Audio('assets/sounds/wing.wav');
let hitSound = new Audio('assets/sounds/hit.wav');
let pointSound = new Audio('assets/sounds/point.wav');

let leaderboard = [];

class Bird {
    constructor() {
        this.x = SCREEN_WIDTH / 5;
        this.y = SCREEN_HEIGHT / 2;
        this.width = 40;
        this.height = 30;
        this.velocity = 0;
    }

    flap() {
        this.velocity = FLAP_STRENGTH;
        wingSound.play();
    }

    update() {
        this.velocity += GRAVITY;
        this.y += this.velocity;
    }

    draw() {
        ctx.drawImage(birdImg, this.x, this.y, this.width, this.height);
    }

    hitbox() {
        return { x: this.x + COLLISION_PADDING, y: this.y + COLLISION_PADDING, width: this.width - 2*COLLISION_PADDING, height: this.height - 2*COLLISION_PADDING };
    }
}

class Pipe {
    constructor(x) {
        this.x = x;
        this.width = PIPE_WIDTH;
        this.topHeight = Math.floor(Math.random() * (SCREEN_HEIGHT - PIPE_GAP - 50) + 50);
        this.bottomY = this.topHeight + PIPE_GAP;
        this.passed = false;
    }

    update() {
        this.x -= PIPE_SPEED;
    }

    draw() {
        // Top pipe
        ctx.save();
        ctx.translate(this.x + this.width/2, this.topHeight/2);
        ctx.scale(1, -1);
        ctx.drawImage(pipeImg, -this.width/2, -this.topHeight/2, this.width, this.topHeight);
        ctx.restore();
        // Bottom pipe
        ctx.drawImage(pipeImg, this.x, this.bottomY, this.width, SCREEN_HEIGHT - this.bottomY);
    }

    topRect() { return {x: this.x, y: 0, width: this.width, height: this.topHeight}; }
    bottomRect() { return {x: this.x, y: this.bottomY, width: this.width, height: SCREEN_HEIGHT - this.bottomY}; }
}

let bird = new Bird();
let pipes = [];
let spawnTimer = 0;
let score = 0;
let gameState = "menu";

function drawText(text, x, y, size = 40) {
    ctx.fillStyle = "white";
    ctx.font = `${size}px Comic Sans MS`;
    ctx.textAlign = "center";
    ctx.fillText(text, x, y);
}

function drawLeaderboard() {
    let sorted = leaderboard.sort((a,b) => b.score - a.score).slice(0,5);
    let html = "<b>Leaderboard</b><br>";
    sorted.forEach((entry,i) => html += `${i+1}. ${entry.name} - ${entry.score}<br>`);
    document.getElementById('leaderboard').innerHTML = html;
}

function rectsCollide(r1, r2) {
    return r1.x < r2.x + r2.width &&
           r1.x + r1.width > r2.x &&
           r1.y < r2.y + r2.height &&
           r1.y + r1.height > r2.y;
}

function gameLoop() {
    ctx.clearRect(0,0,SCREEN_WIDTH,SCREEN_HEIGHT);

    if(gameState === "menu") {
        drawText("Flappy Bird", SCREEN_WIDTH/2, SCREEN_HEIGHT/4, 60);
        drawText("Press SPACE or CLICK to play", SCREEN_WIDTH/2, SCREEN_HEIGHT/2, 30);
        drawLeaderboard();
    } 
    else if(gameState === "playing") {
        bird.update();
        bird.draw();

        spawnTimer++;
        if(spawnTimer > 90) {
            pipes.push(new Pipe(SCREEN_WIDTH));
            spawnTimer = 0;
        }

        pipes.forEach(pipe => {
            pipe.update();
            pipe.draw();

            if(rectsCollide(bird.hitbox(), pipe.topRect()) || rectsCollide(bird.hitbox(), pipe.bottomRect())) {
                hitSound.play();
                gameState = "gameover";
            }

            if(!pipe.passed && pipe.x + pipe.width < bird.x) {
                pipe.passed = true;
                score++;
                pointSound.play();
            }
        });

        pipes = pipes.filter(pipe => pipe.x + pipe.width > 0);

        if(bird.y + bird.height >= SCREEN_HEIGHT || bird.y <= 0) {
            hitSound.play();
            gameState = "gameover";
        }

        drawText(score, 50, 50);
    }
    else if(gameState === "gameover") {
        drawText("GAME OVER", SCREEN_WIDTH/2, SCREEN_HEIGHT/4, 60);
        drawText(`Score: ${score}`, SCREEN_WIDTH/2, SCREEN_HEIGHT/2, 40);

        let playerName = prompt("Enter your name:");
        if(playerName) leaderboard.push({name: playerName, score: score});
        gameState = "menu";
        bird = new Bird();
        pipes = [];
        spawnTimer = 0;
        score = 0;
    }

    requestAnimationFrame(gameLoop);
}

document.addEventListener('keydown', e => {
    if(e.code === "Space") {
        if(gameState === "menu") gameState = "playing";
        else if(gameState === "playing") bird.flap();
    }
});
canvas.addEventListener('mousedown', () => {
    if(gameState === "menu") gameState = "playing";
    else if(gameState === "playing") bird.flap();
});

gameLoop();
</script>
</body>
</html>
