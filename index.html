<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flappy Bird - iOS Friendly</title>
<style>
  body { margin:0; overflow:hidden; background:#000; }
  canvas { display:block; background:url('assets/background.png') no-repeat center/cover; }
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Screen
let SCREEN_WIDTH = window.innerWidth;
let SCREEN_HEIGHT = window.innerHeight;
canvas.width = SCREEN_WIDTH;
canvas.height = SCREEN_HEIGHT;

// Assets
let birdImg = new Image(); birdImg.src='assets/bird.png';
let pipeImg = new Image(); pipeImg.src='assets/pipe.png';
let wingSound = new Audio('assets/sounds/wing.wav');
let hitSound = new Audio('assets/sounds/hit.wav');
let pointSound = new Audio('assets/sounds/point.wav');

// Physics & collision
let GRAVITY = 0.35;     
let FLAP_STRENGTH = -8;
const PIPE_SPEED = 3;
let COLLISION_PADDING = 5;

// Game state
let bird, pipes, spawnTimer, score;
let gameState = "menu";

// Pipes & spacing
let PIPE_WIDTH, PIPE_GAP, spawnInterval;

// Update proportions for device
function updateProportions() {
    SCREEN_WIDTH = window.innerWidth;
    SCREEN_HEIGHT = window.innerHeight;
    canvas.width = SCREEN_WIDTH;
    canvas.height = SCREEN_HEIGHT;

    // Bird size proportional
    bird.width = Math.floor(SCREEN_HEIGHT*0.06);
    bird.height = Math.floor(SCREEN_HEIGHT*0.06);

    // Pipes size
    if(SCREEN_WIDTH <= 768){ // Mobile devices
        PIPE_WIDTH = Math.floor(SCREEN_WIDTH*0.18);
        PIPE_GAP = Math.floor(SCREEN_HEIGHT*0.28);
    } else { // Desktop/tablet
        PIPE_WIDTH = Math.floor(SCREEN_WIDTH*0.12);
        PIPE_GAP = Math.floor(SCREEN_HEIGHT*0.25);
    }
    spawnInterval = Math.min(Math.floor(SCREEN_WIDTH*0.35), 300);

    pipes.forEach(pipe=>pipe.width=PIPE_WIDTH);
}

// Bird class
class Bird {
    constructor() {
        this.x = SCREEN_WIDTH/5;
        this.y = SCREEN_HEIGHT/2;
        this.width = Math.floor(SCREEN_HEIGHT*0.06);
        this.height = Math.floor(SCREEN_HEIGHT*0.06);
        this.velocity = 0;
    }
    flap() { this.velocity = FLAP_STRENGTH; wingSound.play(); }
    update(delta) { this.velocity += GRAVITY*delta; this.y += this.velocity*delta; }
    draw() { ctx.drawImage(birdImg,this.x,this.y,this.width,this.height); }
    hitbox() { return {x:this.x+COLLISION_PADDING, y:this.y+COLLISION_PADDING, width:this.width-2*COLLISION_PADDING, height:this.height-2*COLLISION_PADDING}; }
}

// Pipe class
class Pipe {
    constructor(x) {
        this.x = x;
        this.width = PIPE_WIDTH;
        const minTop = 50;
        const maxTop = SCREEN_HEIGHT - PIPE_GAP - 50;
        this.topHeight = Math.floor(Math.random()*(maxTop - minTop + 1)) + minTop;
        this.bottomY = this.topHeight + PIPE_GAP;
        this.passed = false;
    }
    update(delta) { this.x -= PIPE_SPEED*delta; }
    draw() {
        // Top pipe
        ctx.save();
        ctx.translate(this.x+this.width/2, this.topHeight/2);
        ctx.scale(1,-1);
        ctx.drawImage(pipeImg,-this.width/2,-this.topHeight/2,this.width,this.topHeight);
        ctx.restore();
        // Bottom pipe
        ctx.drawImage(pipeImg,this.x,this.bottomY,this.width,SCREEN_HEIGHT-this.bottomY);
    }
    topRect() { return {x:this.x, y:0, width:this.width, height:this.topHeight}; }
    bottomRect() { return {x:this.x, y:this.bottomY, width:this.width, height:SCREEN_HEIGHT-this.bottomY}; }
}

// Reset game
function resetGame() { bird=new Bird(); pipes=[]; spawnTimer=0; score=0; }

// Draw text
function drawText(text,x,y,size){ ctx.fillStyle="white"; ctx.font=`${size}px Comic Sans MS`; ctx.textAlign="center"; ctx.fillText(text,x,y); }
function rectsCollide(r1,r2){ return r1.x<r2.x+r2.width && r1.x+r1.width>r2.x && r1.y<r2.y+r2.height && r1.y+r1.height>r2.y; }

// Game loop
let lastTime = 0;
function gameLoop(timestamp){
    if(!lastTime) lastTime = timestamp;
    let delta = (timestamp - lastTime)/16.67;
    if(delta > 2) delta = 2; // cap delta for iOS throttling
    lastTime = timestamp;

    updateProportions();
    ctx.clearRect(0,0,SCREEN_WIDTH,SCREEN_HEIGHT);

    if(gameState==="menu"){
        drawText("Flappy Bird", SCREEN_WIDTH/2, SCREEN_HEIGHT/4, 60);
        drawText("Tap/Click or SPACE to play", SCREEN_WIDTH/2, SCREEN_HEIGHT/2, 30);
    } else if(gameState==="playing"){
        bird.update(delta);
        bird.draw();

        spawnTimer += PIPE_SPEED*delta;
        if(spawnTimer>=spawnInterval){ pipes.push(new Pipe(SCREEN_WIDTH)); spawnTimer=0; }

        pipes.forEach(pipe=>{
            pipe.update(delta);
            pipe.draw();

            if(rectsCollide(bird.hitbox(),pipe.topRect()) || rectsCollide(bird.hitbox(),pipe.bottomRect())){
                hitSound.play(); gameState="gameover";
            }
            if(!pipe.passed && pipe.x+pipe.width<bird.x){ pipe.passed=true; score++; pointSound.play(); }
        });

        pipes = pipes.filter(pipe=>pipe.x+pipe.width>0);

        if(bird.y+bird.height>=SCREEN_HEIGHT || bird.y<=0){ hitSound.play(); gameState="gameover"; }

        drawText(score,50,50,40);

    } else if(gameState==="gameover"){
        drawText("GAME OVER", SCREEN_WIDTH/2, SCREEN_HEIGHT/4, 60);
        drawText(`Score: ${score}`, SCREEN_WIDTH/2, SCREEN_HEIGHT/2, 40);
        resetGame(); gameState="menu";
    }

    requestAnimationFrame(gameLoop);
}

// Input
document.addEventListener('keydown', e=>{ if(e.code==="Space"){ if(gameState==="menu") gameState="playing"; else if(gameState==="playing") bird.flap(); }});
canvas.addEventListener('mousedown', ()=>{ if(gameState==="menu") gameState="playing"; else if(gameState==="playing") bird.flap(); });
canvas.addEventListener('touchstart', e=>{
    e.preventDefault(); // prevent scrolling on iOS
    if(gameState==="menu") gameState="playing"; else if(gameState==="playing") bird.flap();
},{passive:false});

// Resize
window.addEventListener('resize', ()=>updateProportions());

// Start
resetGame();
gameLoop();
</script>
</body>
</html>
